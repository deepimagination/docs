

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>imaginaire.generators.fs_vid2vid &mdash; Imaginaire  documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/imaginaire_logo_tight.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">imaginaire_release</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../evaluate.html">evaluate module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../imaginaire.html">imaginaire package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../imaginaire.html#subpackages">Subpackages</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.datasets.html">imaginaire.datasets package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.discriminators.html">imaginaire.discriminators package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.evaluation.html">imaginaire.evaluation package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.generators.html">imaginaire.generators package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.layers.html">imaginaire.layers package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.losses.html">imaginaire.losses package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.model_utils.html">imaginaire.model_utils package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.optimizers.html">imaginaire.optimizers package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.trainers.html">imaginaire.trainers package</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../imaginaire.utils.html">imaginaire.utils package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../imaginaire.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../imaginaire.html#module-imaginaire.config">imaginaire.config module</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../imaginaire.html#module-imaginaire">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../inference.html">inference module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../train.html">train module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Imaginaire</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>imaginaire.generators.fs_vid2vid</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for imaginaire.generators.fs_vid2vid</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (C) 2020 NVIDIA Corporation.  All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># This work is made available under the Nvidia Source Code License-NC.</span>
<span class="c1"># To view a copy of this license, check out LICENSE.md</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.nn.functional</span> <span class="k">as</span> <span class="nn">F</span>

<span class="kn">from</span> <span class="nn">imaginaire.layers</span> <span class="kn">import</span> <span class="p">(</span><span class="n">Conv2dBlock</span><span class="p">,</span> <span class="n">HyperConv2dBlock</span><span class="p">,</span> <span class="n">HyperRes2dBlock</span><span class="p">,</span>
                               <span class="n">LinearBlock</span><span class="p">,</span> <span class="n">Res2dBlock</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">imaginaire.model_utils.fs_vid2vid</span> <span class="kn">import</span> <span class="p">(</span><span class="n">extract_valid_pose_labels</span><span class="p">,</span>
                                               <span class="n">pick_image</span><span class="p">,</span> <span class="n">resample</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">imaginaire.utils.data</span> <span class="kn">import</span> <span class="p">(</span><span class="n">get_paired_input_image_channel_number</span><span class="p">,</span>
                                   <span class="n">get_paired_input_label_channel_number</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">imaginaire.utils.distributed</span> <span class="kn">import</span> <span class="n">master_only_print</span> <span class="k">as</span> <span class="nb">print</span>
<span class="kn">from</span> <span class="nn">imaginaire.utils.init_weight</span> <span class="kn">import</span> <span class="n">weights_init</span>
<span class="kn">from</span> <span class="nn">imaginaire.utils.misc</span> <span class="kn">import</span> <span class="n">get_and_setattr</span><span class="p">,</span> <span class="n">get_nested_attr</span>


<div class="viewcode-block" id="Generator"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator">[docs]</a><span class="k">class</span> <span class="nc">Generator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Few-shot vid2vid generator constructor.</span>

<span class="sd">    Args:</span>
<span class="sd">        gen_cfg (obj): Generator definition part of the yaml config file.</span>
<span class="sd">        data_cfg (obj): Data definition part of the yaml config file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gen_cfg</span><span class="p">,</span> <span class="n">data_cfg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gen_cfg</span> <span class="o">=</span> <span class="n">gen_cfg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_cfg</span> <span class="o">=</span> <span class="n">data_cfg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_frames_G</span> <span class="o">=</span> <span class="n">data_cfg</span><span class="o">.</span><span class="n">num_frames_G</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flow_cfg</span> <span class="o">=</span> <span class="n">flow_cfg</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">flow</span>

        <span class="c1"># For pose dataset.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_pose_data</span> <span class="o">=</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data_cfg</span><span class="p">,</span> <span class="s1">&#39;for_pose_dataset&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_pose_data</span><span class="p">:</span>
            <span class="n">pose_cfg</span> <span class="o">=</span> <span class="n">data_cfg</span><span class="o">.</span><span class="n">for_pose_dataset</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pose_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pose_cfg</span><span class="p">,</span> <span class="s1">&#39;pose_type&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_face_labels</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pose_cfg</span><span class="p">,</span> <span class="s1">&#39;remove_face_labels&#39;</span><span class="p">,</span>
                                              <span class="kc">False</span><span class="p">)</span>

        <span class="n">num_img_channels</span> <span class="o">=</span> <span class="n">get_paired_input_image_channel_number</span><span class="p">(</span><span class="n">data_cfg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span> <span class="o">=</span> <span class="n">num_downsamples</span> <span class="o">=</span> \
            <span class="n">get_and_setattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span> <span class="s1">&#39;num_downsamples&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">conv_kernel_size</span> <span class="o">=</span> <span class="n">get_and_setattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span> <span class="s1">&#39;kernel_size&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">num_filters</span> <span class="o">=</span> <span class="n">get_and_setattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span> <span class="s1">&#39;num_filters&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

        <span class="n">max_num_filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span> <span class="s1">&#39;max_num_filters&#39;</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_num_filters</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">max_num_filters</span> <span class="o">=</span> \
            <span class="nb">min</span><span class="p">(</span><span class="n">max_num_filters</span><span class="p">,</span> <span class="n">num_filters</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">num_downsamples</span><span class="p">))</span>
        <span class="c1"># Get number of filters at each layer in the main branch.</span>
        <span class="n">num_filters_each_layer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_num_filters</span><span class="p">,</span>
                                      <span class="n">num_filters</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">))</span>
                                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Hyper normalization / convolution.</span>
        <span class="n">hyper_cfg</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">hyper</span>
        <span class="c1"># Use adaptive weight generation for SPADE.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_spade</span> <span class="o">=</span> <span class="n">hyper_cfg</span><span class="o">.</span><span class="n">is_hyper_spade</span>
        <span class="c1"># Use adaptive for convolutional layers in the main branch.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_conv</span> <span class="o">=</span> <span class="n">hyper_cfg</span><span class="o">.</span><span class="n">is_hyper_conv</span>
        <span class="c1"># Number of hyper layers.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hyper_cfg</span><span class="p">,</span> <span class="s1">&#39;num_hyper_layers&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span> <span class="o">=</span> <span class="n">num_downsamples</span>
        <span class="n">gen_cfg</span><span class="o">.</span><span class="n">hyper</span><span class="o">.</span><span class="n">num_hyper_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span>
        <span class="c1"># Network weight generator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span> <span class="o">=</span> <span class="n">WeightGenerator</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span> <span class="n">data_cfg</span><span class="p">)</span>

        <span class="c1"># Number of layers to perform multi-spade combine.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_multi_spade_layers</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="o">.</span><span class="n">multi_spade_combine</span><span class="p">,</span>
                                              <span class="s1">&#39;num_layers&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Whether to generate raw output for additional losses.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generate_raw_output</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;generate_raw_output&#39;</span><span class="p">,</span>
                                           <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Main branch image generation.</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">conv_kernel_size</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">activation_norm_type</span> <span class="o">=</span> <span class="n">get_and_setattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span> <span class="s1">&#39;activation_norm_type&#39;</span><span class="p">,</span>
                                               <span class="s1">&#39;sync_batch&#39;</span><span class="p">)</span>
        <span class="n">weight_norm_type</span> <span class="o">=</span> <span class="n">get_and_setattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span> <span class="s1">&#39;weight_norm_type&#39;</span><span class="p">,</span>
                                           <span class="s1">&#39;spectral&#39;</span><span class="p">)</span>
        <span class="n">activation_norm_params</span> <span class="o">=</span> <span class="n">get_and_setattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span>
                                                 <span class="s1">&#39;activation_norm_params&#39;</span><span class="p">,</span>
                                                 <span class="kc">None</span><span class="p">)</span>
        <span class="n">spade_in_channels</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Input channel size in SPADE module.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">spade_in_channels</span> <span class="o">+=</span> <span class="p">[[</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> \
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_multi_spade_layers</span> \
                <span class="k">else</span> <span class="p">[[</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span>

        <span class="n">order</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="o">.</span><span class="n">hyper</span><span class="p">,</span> <span class="s1">&#39;hyper_block_order&#39;</span><span class="p">,</span> <span class="s1">&#39;NAC&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="n">activation_norm_params</span><span class="o">.</span><span class="n">cond_dims</span> <span class="o">=</span> <span class="n">spade_in_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">is_hyper_conv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_conv</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span>
            <span class="n">is_hyper_norm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_spade</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;up_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">HyperRes2dBlock</span><span class="p">(</span>
                <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">conv_kernel_size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                <span class="n">weight_norm_type</span><span class="o">=</span><span class="n">weight_norm_type</span><span class="p">,</span>
                <span class="n">activation_norm_type</span><span class="o">=</span><span class="n">activation_norm_type</span><span class="p">,</span>
                <span class="n">activation_norm_params</span><span class="o">=</span><span class="n">activation_norm_params</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                <span class="n">is_hyper_conv</span><span class="o">=</span><span class="n">is_hyper_conv</span><span class="p">,</span> <span class="n">is_hyper_norm</span><span class="o">=</span><span class="n">is_hyper_norm</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv_img</span> <span class="o">=</span> <span class="n">Conv2dBlock</span><span class="p">(</span><span class="n">num_filters</span><span class="p">,</span> <span class="n">num_img_channels</span><span class="p">,</span>
                                    <span class="n">conv_kernel_size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                                    <span class="n">nonlinearity</span><span class="o">=</span><span class="s1">&#39;leakyrelu&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;AC&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upsample</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">scale_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Flow estimation module.</span>
        <span class="c1"># Whether to warp reference image and combine with the synthesized.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">warp_ref</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;warp_ref&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp_ref</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow_network_ref</span> <span class="o">=</span> <span class="n">FlowGenerator</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="n">data_cfg</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_image_embedding</span> <span class="o">=</span> \
                <span class="n">LabelEmbedder</span><span class="p">(</span><span class="n">flow_cfg</span><span class="o">.</span><span class="n">multi_spade_combine</span><span class="o">.</span><span class="n">embed</span><span class="p">,</span>
                              <span class="n">num_img_channels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># At beginning of training, only train an image generator.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporal_initialized</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="p">,</span> <span class="s1">&#39;init_temporal&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_temporal_network</span><span class="p">()</span>

<div class="viewcode-block" id="Generator.forward"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;few-shot vid2vid generator forward.</span>

<span class="sd">        Args:</span>
<span class="sd">            data (dict) : Dictionary of input data.</span>
<span class="sd">        Returns:</span>
<span class="sd">            output (dict) : Dictionary of output data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span>
        <span class="n">ref_labels</span><span class="p">,</span> <span class="n">ref_images</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ref_labels&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ref_images&#39;</span><span class="p">]</span>
        <span class="n">prev_labels</span><span class="p">,</span> <span class="n">prev_images</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;prev_labels&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;prev_images&#39;</span><span class="p">]</span>
        <span class="n">is_first_frame</span> <span class="o">=</span> <span class="n">prev_labels</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_pose_data</span><span class="p">:</span>
            <span class="n">label</span><span class="p">,</span> <span class="n">prev_labels</span> <span class="o">=</span> <span class="n">extract_valid_pose_labels</span><span class="p">(</span>
                <span class="p">[</span><span class="n">label</span><span class="p">,</span> <span class="n">prev_labels</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_face_labels</span><span class="p">)</span>
            <span class="n">ref_labels</span> <span class="o">=</span> <span class="n">extract_valid_pose_labels</span><span class="p">(</span>
                <span class="n">ref_labels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pose_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_face_labels</span><span class="p">,</span>
                <span class="n">do_remove</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Weight generation.</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">encoded_label</span><span class="p">,</span> <span class="n">conv_weights</span><span class="p">,</span> <span class="n">norm_weights</span><span class="p">,</span> <span class="n">atn</span><span class="p">,</span> <span class="n">atn_vis</span><span class="p">,</span> <span class="n">ref_idx</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span><span class="p">(</span><span class="n">ref_images</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">is_first_frame</span><span class="p">)</span>

        <span class="c1"># Flow estimation.</span>
        <span class="n">flow</span><span class="p">,</span> <span class="n">flow_mask</span><span class="p">,</span> <span class="n">img_warp</span><span class="p">,</span> <span class="n">cond_inputs</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">flow_generation</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">ref_images</span><span class="p">,</span>
                                 <span class="n">prev_labels</span><span class="p">,</span> <span class="n">prev_images</span><span class="p">,</span> <span class="n">ref_idx</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded_label</span><span class="p">)):</span>
            <span class="n">encoded_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoded_label</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_raw_output</span><span class="p">:</span>
            <span class="n">encoded_label_raw</span> <span class="o">=</span> <span class="p">[</span><span class="n">encoded_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                 <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_multi_spade_layers</span><span class="p">)]</span>
            <span class="n">x_raw</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">encoded_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SPADE_combine</span><span class="p">(</span><span class="n">encoded_label</span><span class="p">,</span> <span class="n">cond_inputs</span><span class="p">)</span>

        <span class="c1"># Main branch image generation.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">conv_weight</span> <span class="o">=</span> <span class="n">norm_weight</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_conv</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span><span class="p">:</span>
                <span class="n">conv_weight</span> <span class="o">=</span> <span class="n">conv_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_spade</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span><span class="p">:</span>
                <span class="n">norm_weight</span> <span class="o">=</span> <span class="n">norm_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Main branch residual blocks.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_up_conv_layer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">encoded_label</span><span class="p">,</span>
                                       <span class="n">conv_weight</span><span class="p">,</span> <span class="n">norm_weight</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="c1"># For raw output generation.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_raw_output</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_multi_spade_layers</span><span class="p">:</span>
                <span class="n">x_raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_up_conv_layer</span><span class="p">(</span><span class="n">x_raw</span><span class="p">,</span> <span class="n">encoded_label_raw</span><span class="p">,</span>
                                               <span class="n">conv_weight</span><span class="p">,</span> <span class="n">norm_weight</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_raw</span> <span class="o">=</span> <span class="n">x</span>

        <span class="c1"># Final conv layer.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_raw_output</span><span class="p">:</span>
            <span class="n">img_raw</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_img</span><span class="p">(</span><span class="n">x_raw</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img_raw</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">img_final</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_img</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="n">output</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;fake_images&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_final</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;fake_flow_maps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flow</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;fake_occlusion_masks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flow_mask</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;fake_raw_images&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_raw</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;warped_images&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">img_warp</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;attention_visualization&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atn_vis</span>
        <span class="n">output</span><span class="p">[</span><span class="s1">&#39;ref_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_idx</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="Generator.one_up_conv_layer"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.one_up_conv_layer">[docs]</a>    <span class="k">def</span> <span class="nf">one_up_conv_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">encoded_label</span><span class="p">,</span> <span class="n">conv_weight</span><span class="p">,</span> <span class="n">norm_weight</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;One residual block layer in the main branch.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (4D tensor) : Current feature map.</span>
<span class="sd">            encoded_label (list of tensors) : Encoded input label maps.</span>
<span class="sd">            conv_weight (list of tensors) : Hyper conv weights.</span>
<span class="sd">            norm_weight (list of tensors) : Hyper norm weights.</span>
<span class="sd">            i (int) : Layer index.</span>
<span class="sd">        Returns:</span>
<span class="sd">            x (4D tensor) : Output feature map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">layer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;up_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">encoded_label</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">conv_weights</span><span class="o">=</span><span class="n">conv_weight</span><span class="p">,</span>
                  <span class="n">norm_weights</span><span class="o">=</span><span class="n">norm_weight</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="Generator.init_temporal_network"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.init_temporal_network">[docs]</a>    <span class="k">def</span> <span class="nf">init_temporal_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg_init</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;When starting training multiple frames, initialize the flow network.</span>

<span class="sd">        Args:</span>
<span class="sd">            cfg_init (dict) : Weight initialization config.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flow_cfg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_cfg</span>
        <span class="n">emb_cfg</span> <span class="o">=</span> <span class="n">flow_cfg</span><span class="o">.</span><span class="n">multi_spade_combine</span><span class="o">.</span><span class="n">embed</span>
        <span class="n">num_frames_G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_frames_G</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temporal_initialized</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sep_prev_flownet</span> <span class="o">=</span> <span class="n">flow_cfg</span><span class="o">.</span><span class="n">sep_prev_flow</span> <span class="ow">or</span> <span class="p">(</span><span class="n">num_frames_G</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> \
            <span class="ow">or</span> <span class="ow">not</span> <span class="n">flow_cfg</span><span class="o">.</span><span class="n">warp_ref</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_prev_flownet</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow_network_temp</span> <span class="o">=</span> <span class="n">FlowGenerator</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_cfg</span><span class="p">,</span>
                                                   <span class="n">num_frames_G</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cfg_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flow_network_temp</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">weights_init</span><span class="p">(</span><span class="n">cfg_init</span><span class="o">.</span><span class="n">type</span><span class="p">,</span>
                                                          <span class="n">cfg_init</span><span class="o">.</span><span class="n">gain</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow_network_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_network_ref</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sep_prev_embedding</span> <span class="o">=</span> <span class="n">emb_cfg</span><span class="o">.</span><span class="n">sep_warp_embed</span> <span class="ow">or</span> \
            <span class="ow">not</span> <span class="n">flow_cfg</span><span class="o">.</span><span class="n">warp_ref</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_prev_embedding</span><span class="p">:</span>
            <span class="n">num_img_channels</span> <span class="o">=</span> <span class="n">get_paired_input_image_channel_number</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_cfg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_image_embedding</span> <span class="o">=</span> \
                <span class="n">LabelEmbedder</span><span class="p">(</span><span class="n">emb_cfg</span><span class="p">,</span> <span class="n">num_img_channels</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cfg_init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prev_image_embedding</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span>
                    <span class="n">weights_init</span><span class="p">(</span><span class="n">cfg_init</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">cfg_init</span><span class="o">.</span><span class="n">gain</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prev_image_embedding</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_image_embedding</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp_ref</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_prev_flownet</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_network_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flow_network_ref</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">flow_network_temp</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initialized temporal flow network with the reference &#39;</span>
                      <span class="s1">&#39;one.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_prev_embedding</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">init_network_weights</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_image_embedding</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">prev_image_embedding</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initialized temporal embedding network with the &#39;</span>
                      <span class="s1">&#39;reference one.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flow_temp_is_initalized</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Generator.init_network_weights"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.init_network_weights">[docs]</a>    <span class="k">def</span> <span class="nf">init_network_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net_src</span><span class="p">,</span> <span class="n">net_dst</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Initialize weights in net_dst with those in net_src.&quot;&quot;&quot;</span>
        <span class="n">source_weights</span> <span class="o">=</span> <span class="n">net_src</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span>
        <span class="n">target_weights</span> <span class="o">=</span> <span class="n">net_dst</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">source_weights</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">target_weights</span> <span class="ow">and</span> <span class="n">target_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
                <span class="n">target_weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="n">net_dst</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">target_weights</span><span class="p">)</span></div>

<div class="viewcode-block" id="Generator.load_pretrained_network"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.load_pretrained_network">[docs]</a>    <span class="k">def</span> <span class="nf">load_pretrained_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pretrained_dict</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;module.&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Load the pretrained network into self network.</span>

<span class="sd">        Args:</span>
<span class="sd">            pretrained_dict (dict): Pretrained network weights.</span>
<span class="sd">            prefix (str): Prefix to the network weights name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(pretrained_dict.keys())</span>
        <span class="n">model_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Pretrained network has fewer layers; The following are &#39;</span>
              <span class="s1">&#39;not initialized:&#39;</span><span class="p">)</span>

        <span class="n">not_initialized</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">model_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">kp</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">k</span>
            <span class="k">if</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">pretrained_dict</span> <span class="ow">and</span> <span class="n">v</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">pretrained_dict</span><span class="p">[</span><span class="n">kp</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
                <span class="n">model_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">pretrained_dict</span><span class="p">[</span><span class="n">kp</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">not_initialized</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">not_initialized</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_dict</span><span class="p">)</span></div>

<div class="viewcode-block" id="Generator.reset"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Reset the network at the beginning of a sequence.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_generator</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div>

<div class="viewcode-block" id="Generator.flow_generation"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.flow_generation">[docs]</a>    <span class="k">def</span> <span class="nf">flow_generation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">ref_labels</span><span class="p">,</span> <span class="n">ref_images</span><span class="p">,</span> <span class="n">prev_labels</span><span class="p">,</span>
                        <span class="n">prev_images</span><span class="p">,</span> <span class="n">ref_idx</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generates flows and masks for warping reference / previous images.</span>

<span class="sd">        Args:</span>
<span class="sd">            label (NxCxHxW tensor): Target label map.</span>
<span class="sd">            ref_labels (NxKxCxHxW tensor): Reference label maps.</span>
<span class="sd">            ref_images (NxKx3xHxW tensor): Reference images.</span>
<span class="sd">            prev_labels (NxTxCxHxW tensor): Previous label maps.</span>
<span class="sd">            prev_images (NxTx3xHxW tensor): Previous images.</span>
<span class="sd">            ref_idx (Nx1 tensor): Index for which image to use from the</span>
<span class="sd">            reference images.</span>
<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">              - flow (list of Nx2xHxW tensor): Optical flows.</span>
<span class="sd">              - occ_mask (list of Nx1xHxW tensor): Occlusion masks.</span>
<span class="sd">              - img_warp (list of Nx3xHxW tensor): Warped reference / previous</span>
<span class="sd">                images.</span>
<span class="sd">              - cond_inputs (list of Nx4xHxW tensor): Conditional inputs for</span>
<span class="sd">                SPADE combination.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Pick an image in the reference images using ref_idx.</span>
        <span class="n">ref_label</span><span class="p">,</span> <span class="n">ref_image</span> <span class="o">=</span> <span class="n">pick_image</span><span class="p">([</span><span class="n">ref_labels</span><span class="p">,</span> <span class="n">ref_images</span><span class="p">],</span> <span class="n">ref_idx</span><span class="p">)</span>
        <span class="c1"># Only start using prev frames when enough prev frames are generated.</span>
        <span class="n">has_prev</span> <span class="o">=</span> <span class="n">prev_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> \
            <span class="n">prev_labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_frames_G</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">flow</span><span class="p">,</span> <span class="n">occ_mask</span><span class="p">,</span> <span class="n">img_warp</span><span class="p">,</span> <span class="n">cond_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> \
                                                <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">warp_ref</span><span class="p">:</span>
            <span class="c1"># Generate flows/masks for warping the reference image.</span>
            <span class="n">flow_ref</span><span class="p">,</span> <span class="n">occ_mask_ref</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">flow_network_ref</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">,</span> <span class="n">ref_image</span><span class="p">)</span>
            <span class="n">ref_image_warp</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">ref_image</span><span class="p">,</span> <span class="n">flow_ref</span><span class="p">)</span>
            <span class="n">flow</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">occ_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_warp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">flow_ref</span><span class="p">,</span> <span class="n">occ_mask_ref</span><span class="p">,</span> <span class="n">ref_image_warp</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="c1"># Concat warped image and occlusion mask to form the conditional</span>
            <span class="c1"># input.</span>
            <span class="n">cond_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">img_warp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">occ_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">temporal_initialized</span> <span class="ow">and</span> <span class="n">has_prev</span><span class="p">:</span>
            <span class="c1"># Generate flows/masks for warping the previous image.</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">prev_labels</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">prev_labels_concat</span> <span class="o">=</span> <span class="n">prev_labels</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">prev_images_concat</span> <span class="o">=</span> <span class="n">prev_images</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
            <span class="n">flow_prev</span><span class="p">,</span> <span class="n">occ_mask_prev</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">flow_network_temp</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">prev_labels_concat</span><span class="p">,</span>
                                       <span class="n">prev_images_concat</span><span class="p">)</span>
            <span class="n">img_prev_warp</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">prev_images</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">flow_prev</span><span class="p">)</span>
            <span class="n">flow</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">occ_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">img_warp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">flow_prev</span><span class="p">,</span> <span class="n">occ_mask_prev</span><span class="p">,</span> <span class="n">img_prev_warp</span>
            <span class="n">cond_inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">img_warp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">occ_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">flow</span><span class="p">,</span> <span class="n">occ_mask</span><span class="p">,</span> <span class="n">img_warp</span><span class="p">,</span> <span class="n">cond_inputs</span></div>

<div class="viewcode-block" id="Generator.SPADE_combine"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.SPADE_combine">[docs]</a>    <span class="k">def</span> <span class="nf">SPADE_combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoded_label</span><span class="p">,</span> <span class="n">cond_inputs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Using Multi-SPADE to combine raw synthesized image with warped</span>
<span class="sd">        images.</span>

<span class="sd">        Args:</span>
<span class="sd">            encoded_label (list of tensors): Original label map embeddings.</span>
<span class="sd">            cond_inputs (list of tensors): New SPADE conditional inputs from the</span>
<span class="sd">                warped images.</span>
<span class="sd">        Returns:</span>
<span class="sd">            encoded_label (list of tensors): Combined conditional inputs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Generate the conditional embeddings from inputs.</span>
        <span class="n">embedded_img_feat</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cond_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">embedded_img_feat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_image_embedding</span><span class="p">(</span><span class="n">cond_inputs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">cond_inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">embedded_img_feat</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev_image_embedding</span><span class="p">(</span><span class="n">cond_inputs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Combine the original encoded label maps with new conditional</span>
        <span class="c1"># embeddings.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_multi_spade_layers</span><span class="p">):</span>
            <span class="n">encoded_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                                 <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">embedded_img_feat</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">encoded_label</span></div>

<div class="viewcode-block" id="Generator.custom_init"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.Generator.custom_init">[docs]</a>    <span class="k">def</span> <span class="nf">custom_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;This function is for dealing with the numerical issue that might</span>
<span class="sd">        occur when doing mixed precision training.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Use custom initialization for the generator.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">named_modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;weight_generator.ref_label_&#39;</span> <span class="ow">in</span> <span class="n">k</span> <span class="ow">and</span> <span class="s1">&#39;norm&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">:</span>
                <span class="n">m</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-1</span></div></div>


<div class="viewcode-block" id="WeightGenerator"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightGenerator">[docs]</a><span class="k">class</span> <span class="nc">WeightGenerator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Weight generator constructor.</span>

<span class="sd">    Args:</span>
<span class="sd">        gen_cfg (obj): Generator definition part of the yaml config file.</span>
<span class="sd">        data_cfg (obj): Data definition part of the yaml config file</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gen_cfg</span><span class="p">,</span> <span class="n">data_cfg</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_cfg</span> <span class="o">=</span> <span class="n">data_cfg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embed_cfg</span> <span class="o">=</span> <span class="n">embed_cfg</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">embed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embed_arch</span> <span class="o">=</span> <span class="n">embed_cfg</span><span class="o">.</span><span class="n">arch</span>

        <span class="n">num_filters</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">num_filters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_num_filters</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">max_num_filters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span> <span class="o">=</span> <span class="n">num_downsamples</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">num_downsamples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_filters_each_layer</span> <span class="o">=</span> <span class="n">num_filters_each_layer</span> <span class="o">=</span> \
            <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_num_filters</span><span class="p">,</span> <span class="n">num_filters</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">))</span>
             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">embed_cfg</span><span class="p">,</span> <span class="s1">&#39;num_filters&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_filters</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Embedding network must have the same number of &#39;</span>
                             <span class="s1">&#39;filters as generator.&#39;</span><span class="p">)</span>

        <span class="c1"># Normalization params.</span>
        <span class="n">hyper_cfg</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">hyper</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hyper_cfg</span><span class="p">,</span> <span class="s1">&#39;kernel_size&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">activation_norm_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hyper_cfg</span><span class="p">,</span> <span class="s1">&#39;activation_norm_type&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;sync_batch&#39;</span><span class="p">)</span>
        <span class="n">weight_norm_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hyper_cfg</span><span class="p">,</span> <span class="s1">&#39;weight_norm_type&#39;</span><span class="p">,</span> <span class="s1">&#39;spectral&#39;</span><span class="p">)</span>
        <span class="c1"># Conv kernel size in main branch.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_kernel_size</span> <span class="o">=</span> <span class="n">conv_kernel_size</span> <span class="o">=</span> <span class="n">gen_cfg</span><span class="o">.</span><span class="n">kernel_size</span>
        <span class="c1"># Conv kernel size in embedding network.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embed_kernel_size</span> <span class="o">=</span> <span class="n">embed_kernel_size</span> <span class="o">=</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="o">.</span><span class="n">embed</span><span class="p">,</span> <span class="s1">&#39;kernel_size&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="c1"># Conv kernel size in SPADE.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span> <span class="o">=</span> <span class="n">kernel_size</span> <span class="o">=</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="o">.</span><span class="n">activation_norm_params</span><span class="p">,</span> <span class="s1">&#39;kernel_size&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Input channel size in SPADE module.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spade_in_channels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spade_in_channels</span> <span class="o">+=</span> <span class="p">[</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="c1"># Hyper normalization / convolution.</span>
        <span class="c1"># Use adaptive weight generation for SPADE.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_spade</span> <span class="o">=</span> <span class="n">hyper_cfg</span><span class="o">.</span><span class="n">is_hyper_spade</span>
        <span class="c1"># Use adaptive for the label embedding network.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_embed</span> <span class="o">=</span> <span class="n">hyper_cfg</span><span class="o">.</span><span class="n">is_hyper_embed</span>
        <span class="c1"># Use adaptive for convolutional layers in the main branch.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_conv</span> <span class="o">=</span> <span class="n">hyper_cfg</span><span class="o">.</span><span class="n">is_hyper_conv</span>
        <span class="c1"># Number of hyper layers.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span> <span class="o">=</span> <span class="n">hyper_cfg</span><span class="o">.</span><span class="n">num_hyper_layers</span>
        <span class="c1"># Order of operations in the conv block.</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">gen_cfg</span><span class="o">.</span><span class="n">hyper</span><span class="p">,</span> <span class="s1">&#39;hyper_block_order&#39;</span><span class="p">,</span> <span class="s1">&#39;NAC&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_before_norm</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">order</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>

        <span class="c1"># For reference image encoding.</span>
        <span class="c1"># How to utilize the reference label map: concat | mul.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat_ref_label</span> <span class="o">=</span> <span class="s1">&#39;concat&#39;</span> <span class="ow">in</span> <span class="n">hyper_cfg</span><span class="o">.</span><span class="n">method_to_use_ref_labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span> <span class="o">=</span> <span class="s1">&#39;mul&#39;</span> <span class="ow">in</span> <span class="n">hyper_cfg</span><span class="o">.</span><span class="n">method_to_use_ref_labels</span>
        <span class="c1"># Output spatial size for adaptive pooling layer.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sh_fix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sw_fix</span> <span class="o">=</span> <span class="mi">32</span>
        <span class="c1"># Number of fc layers in weight generation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_fc_layers</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hyper_cfg</span><span class="p">,</span> <span class="s1">&#39;num_fc_layers&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Reference image encoding network.</span>
        <span class="n">num_input_channels</span> <span class="o">=</span> <span class="n">get_paired_input_label_channel_number</span><span class="p">(</span><span class="n">data_cfg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_input_channels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_input_channels</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data_cfg</span><span class="p">,</span> <span class="s1">&#39;label_channels&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">get_nested_attr</span><span class="p">(</span><span class="n">data_cfg</span><span class="p">,</span> <span class="s1">&#39;for_pose_dataset.pose_type&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;both&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;open&#39;</span><span class="p">:</span>
            <span class="n">num_input_channels</span> <span class="o">-=</span> <span class="mi">3</span>
        <span class="n">data_cfg</span><span class="o">.</span><span class="n">num_input_channels</span> <span class="o">=</span> <span class="n">num_input_channels</span>
        <span class="n">num_img_channels</span> <span class="o">=</span> <span class="n">get_paired_input_image_channel_number</span><span class="p">(</span><span class="n">data_cfg</span><span class="p">)</span>
        <span class="n">num_ref_channels</span> <span class="o">=</span> <span class="n">num_img_channels</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_input_channels</span>
                                               <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat_ref_label</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">conv_2d_block</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">Conv2dBlock</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
            <span class="n">padding</span><span class="o">=</span><span class="p">(</span><span class="n">kernel_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">weight_norm_type</span><span class="o">=</span><span class="n">weight_norm_type</span><span class="p">,</span>
            <span class="n">activation_norm_type</span><span class="o">=</span><span class="n">activation_norm_type</span><span class="p">,</span>
            <span class="n">nonlinearity</span><span class="o">=</span><span class="s1">&#39;leakyrelu&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ref_img_first</span> <span class="o">=</span> <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">num_ref_channels</span><span class="p">,</span> <span class="n">num_filters</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ref_label_first</span> <span class="o">=</span> <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">num_input_channels</span><span class="p">,</span>
                                                 <span class="n">num_filters</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span><span class="p">):</span>
            <span class="n">in_ch</span><span class="p">,</span> <span class="n">out_ch</span> <span class="o">=</span> <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> \
                <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ref_img_down_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                    <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">in_ch</span><span class="p">,</span> <span class="n">out_ch</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ref_img_up_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">in_ch</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ref_label_down_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                        <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">in_ch</span><span class="p">,</span> <span class="n">out_ch</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ref_label_up_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                        <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">in_ch</span><span class="p">))</span>

        <span class="c1"># Normalization / main branch conv weight generation.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_spade</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_conv</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span><span class="p">):</span>
                <span class="n">ch_in</span><span class="p">,</span> <span class="n">ch_out</span> <span class="o">=</span> <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> \
                    <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">conv_ks2</span> <span class="o">=</span> <span class="n">conv_kernel_size</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">embed_ks2</span> <span class="o">=</span> <span class="n">embed_kernel_size</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">spade_ks2</span> <span class="o">=</span> <span class="n">kernel_size</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">spade_in_ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spade_in_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">fc_names</span><span class="p">,</span> <span class="n">fc_ins</span><span class="p">,</span> <span class="n">fc_outs</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_spade</span><span class="p">:</span>
                    <span class="n">fc0_out</span> <span class="o">=</span> <span class="n">fcs_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">spade_in_ch</span> <span class="o">*</span> <span class="n">spade_ks2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_before_norm</span> <span class="k">else</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">fc1_out</span> <span class="o">=</span> <span class="p">(</span><span class="n">spade_in_ch</span> <span class="o">*</span> <span class="n">spade_ks2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="k">if</span> <span class="n">ch_in</span> <span class="o">!=</span> <span class="n">ch_out</span> <span class="k">else</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">fc_names</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;fc_spade_0&#39;</span><span class="p">,</span> <span class="s1">&#39;fc_spade_1&#39;</span><span class="p">,</span> <span class="s1">&#39;fc_spade_s&#39;</span><span class="p">]</span>
                    <span class="n">fc_ins</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ch_out</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
                    <span class="n">fc_outs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fc0_out</span><span class="p">,</span> <span class="n">fc1_out</span><span class="p">,</span> <span class="n">fcs_out</span><span class="p">]</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_embed</span><span class="p">:</span>
                        <span class="n">fc_names</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;fc_spade_e&#39;</span><span class="p">]</span>
                        <span class="n">fc_ins</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ch_out</span><span class="p">]</span>
                        <span class="n">fc_outs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ch_in</span> <span class="o">*</span> <span class="n">embed_ks2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_conv</span><span class="p">:</span>
                    <span class="n">fc0_out</span> <span class="o">=</span> <span class="n">ch_out</span> <span class="o">*</span> <span class="n">conv_ks2</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">fc1_out</span> <span class="o">=</span> <span class="n">ch_in</span> <span class="o">*</span> <span class="n">conv_ks2</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">fcs_out</span> <span class="o">=</span> <span class="n">ch_out</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">fc_names</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;fc_conv_0&#39;</span><span class="p">,</span> <span class="s1">&#39;fc_conv_1&#39;</span><span class="p">,</span> <span class="s1">&#39;fc_conv_s&#39;</span><span class="p">]</span>
                    <span class="n">fc_ins</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ch_in</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
                    <span class="n">fc_outs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fc0_out</span><span class="p">,</span> <span class="n">fc1_out</span><span class="p">,</span> <span class="n">fcs_out</span><span class="p">]</span>

                <span class="n">linear_block</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">LinearBlock</span><span class="p">,</span>
                                       <span class="n">weight_norm_type</span><span class="o">=</span><span class="s1">&#39;spectral&#39;</span><span class="p">,</span>
                                       <span class="n">nonlinearity</span><span class="o">=</span><span class="s1">&#39;leakyrelu&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fc_names</span><span class="p">):</span>
                    <span class="n">fc_in</span> <span class="o">=</span> <span class="n">fc_ins</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span> \
                        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sh_fix</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sw_fix</span>
                    <span class="n">fc_layer</span> <span class="o">=</span> <span class="p">[</span><span class="n">linear_block</span><span class="p">(</span><span class="n">fc_in</span><span class="p">,</span> <span class="n">ch_out</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_fc_layers</span><span class="p">):</span>
                        <span class="n">fc_layer</span> <span class="o">+=</span> <span class="p">[</span><span class="n">linear_block</span><span class="p">(</span><span class="n">ch_out</span><span class="p">,</span> <span class="n">ch_out</span><span class="p">)]</span>
                    <span class="n">fc_layer</span> <span class="o">+=</span> <span class="p">[</span><span class="n">LinearBlock</span><span class="p">(</span><span class="n">ch_out</span><span class="p">,</span> <span class="n">fc_outs</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                                             <span class="n">weight_norm_type</span><span class="o">=</span><span class="s1">&#39;spectral&#39;</span><span class="p">)]</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">fc_layer</span><span class="p">))</span>

        <span class="c1"># Label embedding network.</span>
        <span class="n">num_hyper_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_embed</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_embedding</span> <span class="o">=</span> <span class="n">LabelEmbedder</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embed_cfg</span><span class="p">,</span>
                                             <span class="n">num_input_channels</span><span class="p">,</span>
                                             <span class="n">num_hyper_layers</span><span class="o">=</span><span class="n">num_hyper_layers</span><span class="p">)</span>

        <span class="c1"># For multiple reference images.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">hyper_cfg</span><span class="p">,</span> <span class="s1">&#39;attention&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_downsample_atn</span> <span class="o">=</span> <span class="n">get_and_setattr</span><span class="p">(</span><span class="n">hyper_cfg</span><span class="o">.</span><span class="n">attention</span><span class="p">,</span>
                                                      <span class="s1">&#39;num_downsamples&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">data_cfg</span><span class="o">.</span><span class="n">initial_few_shot_K</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">attention_module</span> <span class="o">=</span> <span class="n">AttentionModule</span><span class="p">(</span><span class="n">hyper_cfg</span><span class="p">,</span> <span class="n">data_cfg</span><span class="p">,</span>
                                                        <span class="n">conv_2d_block</span><span class="p">,</span>
                                                        <span class="n">num_filters_each_layer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_downsample_atn</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="WeightGenerator.forward"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightGenerator.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_image</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">is_first_frame</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Generate network weights based on the reference images.</span>

<span class="sd">        Args:</span>
<span class="sd">            ref_image (NxKx3xHxW tensor): Reference images.</span>
<span class="sd">            ref_label (NxKxCxHxW tensor): Reference labels.</span>
<span class="sd">            label (NxCxHxW tensor): Target label.</span>
<span class="sd">            is_first_frame (bool): Whether the current frame is the first frame.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">              - x (NxC2xH2xW2 tensor): Encoded features from reference images</span>
<span class="sd">                for the main branch (as input to the decoder).</span>
<span class="sd">              - encoded_label (list of tensors): Encoded target label map for</span>
<span class="sd">                SPADE.</span>
<span class="sd">              - conv_weights (list of tensors): Network weights for conv</span>
<span class="sd">                layers in the main network.</span>
<span class="sd">              - norm_weights (list of tensors): Network weights for SPADE</span>
<span class="sd">                layers in the main network.</span>
<span class="sd">              - attention (Nx(KxH1xW1)x(H1xW1) tensor): Attention maps.</span>
<span class="sd">              - atn_vis (1x1xH1xW1 tensor): Visualization for attention</span>
<span class="sd">                scores.</span>
<span class="sd">              - ref_idx (Nx1 tensor): Index for which image to use from the</span>
<span class="sd">                reference images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">ref_image</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">ref_image</span> <span class="o">=</span> <span class="n">ref_image</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ref_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ref_label</span> <span class="o">=</span> <span class="n">ref_label</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

        <span class="c1"># Encode the reference images to get the features.</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">encoded_ref</span><span class="p">,</span> <span class="n">atn</span><span class="p">,</span> <span class="n">atn_vis</span><span class="p">,</span> <span class="n">ref_idx</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">encode_reference</span><span class="p">(</span><span class="n">ref_image</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="c1"># If the reference image has changed, recompute the network weights.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">or</span> <span class="n">is_first_frame</span> <span class="ow">or</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">embedding_weights</span><span class="p">,</span> <span class="n">norm_weights</span><span class="p">,</span> <span class="n">conv_weights</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_spade</span><span class="p">:</span>
                    <span class="n">feat</span> <span class="o">=</span> <span class="n">encoded_ref</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded_ref</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                    <span class="n">embedding_weight</span><span class="p">,</span> <span class="n">norm_weight</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">get_norm_weights</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                    <span class="n">embedding_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">embedding_weight</span><span class="p">)</span>
                    <span class="n">norm_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm_weight</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_conv</span><span class="p">:</span>
                    <span class="n">feat</span> <span class="o">=</span> <span class="n">encoded_ref</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded_ref</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
                    <span class="n">conv_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_conv_weights</span><span class="p">(</span><span class="n">feat</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">embedding_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_weights</span> \
                    <span class="o">=</span> <span class="n">embedding_weights</span><span class="p">,</span> <span class="n">conv_weights</span><span class="p">,</span> <span class="n">norm_weights</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&#39;Reusing network weights.&#39;)</span>
            <span class="n">embedding_weights</span><span class="p">,</span> <span class="n">conv_weights</span><span class="p">,</span> <span class="n">norm_weights</span> \
                <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_weights</span>

        <span class="c1"># Encode the target label to get the encoded features.</span>
        <span class="n">encoded_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_embedding</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="p">(</span>
            <span class="n">embedding_weights</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_embed</span> <span class="k">else</span> <span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">encoded_label</span><span class="p">,</span> <span class="n">conv_weights</span><span class="p">,</span> <span class="n">norm_weights</span><span class="p">,</span> \
            <span class="n">atn</span><span class="p">,</span> <span class="n">atn_vis</span><span class="p">,</span> <span class="n">ref_idx</span></div>

<div class="viewcode-block" id="WeightGenerator.encode_reference"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightGenerator.encode_reference">[docs]</a>    <span class="k">def</span> <span class="nf">encode_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_image</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Encode the reference image to get features for weight generation.</span>

<span class="sd">        Args:</span>
<span class="sd">            ref_image ((NxK)x3xHxW tensor): Reference images.</span>
<span class="sd">            ref_label ((NxK)xCxHxW tensor): Reference labels.</span>
<span class="sd">            label (NxCxHxW tensor): Target label.</span>
<span class="sd">            k (int): Number of reference images.</span>
<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">              - x (NxC2xH2xW2 tensor): Encoded features from reference images</span>
<span class="sd">                for the main branch (as input to the decoder).</span>
<span class="sd">              - encoded_ref (list of tensors): Encoded features from reference</span>
<span class="sd">                images for the weight generation branch.</span>
<span class="sd">              - attention (Nx(KxH1xW1)x(H1xW1) tensor): Attention maps.</span>
<span class="sd">              - atn_vis (1x1xH1xW1 tensor): Visualization for attention scores.</span>
<span class="sd">              - ref_idx (Nx1 tensor): Index for which image to use from the</span>
<span class="sd">                reference images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat_ref_label</span><span class="p">:</span>
            <span class="c1"># Concat reference label map and image together for encoding.</span>
            <span class="n">concat_ref</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">ref_image</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_img_first</span><span class="p">(</span><span class="n">concat_ref</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
            <span class="c1"># Apply conv to both reference label and image, then multiply them</span>
            <span class="c1"># together for encoding.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_img_first</span><span class="p">(</span><span class="n">ref_image</span><span class="p">)</span>
            <span class="n">x_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_label_first</span><span class="p">(</span><span class="n">ref_label</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_img_first</span><span class="p">(</span><span class="n">ref_image</span><span class="p">)</span>

        <span class="c1"># Attention map and the index of the most similar reference image.</span>
        <span class="n">atn</span> <span class="o">=</span> <span class="n">atn_vis</span> <span class="o">=</span> <span class="n">ref_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ref_img_down_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
                <span class="n">x_label</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ref_label_down_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x_label</span><span class="p">)</span>

            <span class="c1"># Combine different reference images at a particular layer.</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_downsample_atn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">atn</span><span class="p">,</span> <span class="n">atn_vis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention_module</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
                    <span class="n">x_label</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention_module</span><span class="p">(</span><span class="n">x_label</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span>
                                                          <span class="n">atn</span><span class="p">)</span>

                <span class="n">atn_sum</span> <span class="o">=</span> <span class="n">atn</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">label</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">ref_idx</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">atn_sum</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Get all corresponding layers in the encoder output for generating</span>
        <span class="c1"># weights in corresponding layers.</span>
        <span class="n">encoded_image_ref</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
            <span class="n">encoded_ref_label</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_label</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span><span class="p">)):</span>
            <span class="n">conv</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ref_img_up_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span>
                <span class="n">encoded_image_ref</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">encoded_image_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conv</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
                <span class="n">conv_label</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ref_label_up_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span>
                    <span class="n">encoded_ref_label</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">encoded_ref_label</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conv_label</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
            <span class="n">encoded_ref</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">encoded_image_ref</span><span class="p">)):</span>
                <span class="n">conv</span><span class="p">,</span> <span class="n">conv_label</span> \
                    <span class="o">=</span> <span class="n">encoded_image_ref</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">encoded_ref_label</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">conv</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
                <span class="n">conv_label</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">conv_label</span><span class="p">)</span>
                <span class="n">conv_prod</span> <span class="o">=</span> <span class="p">(</span><span class="n">conv</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span> <span class="o">*</span>
                             <span class="n">conv_label</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
                                             <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">encoded_ref</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conv_prod</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">encoded_ref</span> <span class="o">=</span> <span class="n">encoded_image_ref</span>
        <span class="n">encoded_ref</span> <span class="o">=</span> <span class="n">encoded_ref</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">encoded_ref</span><span class="p">,</span> <span class="n">atn</span><span class="p">,</span> <span class="n">atn_vis</span><span class="p">,</span> <span class="n">ref_idx</span></div>

<div class="viewcode-block" id="WeightGenerator.get_norm_weights"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightGenerator.get_norm_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_norm_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adaptively generate weights for SPADE in layer i of generator.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (NxCxHxW tensor): Input features.</span>
<span class="sd">            i (int): Layer index.</span>
<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">              - embedding_weights (list of tensors): Weights for the label</span>
<span class="sd">                embedding network.</span>
<span class="sd">              - norm_weights (list of tensors): Weights for the SPADE layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
            <span class="c1"># Get fixed output size for fc layers.</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">AdaptiveAvgPool2d</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_fix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sw_fix</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">in_ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">out_ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">spade_ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spade_in_channels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">eks</span><span class="p">,</span> <span class="n">sks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embed_kernel_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel_size</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">weight_reshaper</span> <span class="o">=</span> <span class="n">WeightReshaper</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_embed_input</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Weights for the label embedding network.</span>
        <span class="n">embedding_weights</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_hyper_embed</span><span class="p">:</span>
            <span class="n">fc_e</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fc_spade_e_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;decoder&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">embed_arch</span><span class="p">:</span>
                <span class="n">weight_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_ch</span><span class="p">,</span> <span class="n">out_ch</span><span class="p">,</span> <span class="n">eks</span><span class="p">,</span> <span class="n">eks</span><span class="p">]</span>
                <span class="n">fc_e</span> <span class="o">=</span> <span class="n">fc_e</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">in_ch</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">weight_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_ch</span><span class="p">,</span> <span class="n">in_ch</span><span class="p">,</span> <span class="n">eks</span><span class="p">,</span> <span class="n">eks</span><span class="p">]</span>
            <span class="n">embedding_weights</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_weight</span><span class="p">(</span><span class="n">fc_e</span><span class="p">,</span>
                                                               <span class="n">weight_shape</span><span class="p">)</span>

        <span class="c1"># Weights for the 3 layers in SPADE module: conv_0, conv_1,</span>
        <span class="c1"># and shortcut.</span>
        <span class="n">fc_0</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fc_spade_0_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fc_1</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fc_spade_1_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fc_s</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fc_spade_s_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_before_norm</span><span class="p">:</span>
            <span class="n">out_ch</span> <span class="o">=</span> <span class="n">in_ch</span>
        <span class="n">weight_0</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_weight</span><span class="p">(</span><span class="n">fc_0</span><span class="p">,</span> <span class="p">[</span><span class="n">out_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">spade_ch</span><span class="p">,</span>
                                                         <span class="n">sks</span><span class="p">,</span> <span class="n">sks</span><span class="p">])</span>
        <span class="n">weight_1</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_weight</span><span class="p">(</span><span class="n">fc_1</span><span class="p">,</span> <span class="p">[</span><span class="n">in_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">spade_ch</span><span class="p">,</span>
                                                         <span class="n">sks</span><span class="p">,</span> <span class="n">sks</span><span class="p">])</span>
        <span class="n">weight_s</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_weight</span><span class="p">(</span><span class="n">fc_s</span><span class="p">,</span> <span class="p">[</span><span class="n">out_ch</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">spade_ch</span><span class="p">,</span>
                                                         <span class="n">sks</span><span class="p">,</span> <span class="n">sks</span><span class="p">])</span>
        <span class="n">norm_weights</span> <span class="o">=</span> <span class="p">[</span><span class="n">weight_0</span><span class="p">,</span> <span class="n">weight_1</span><span class="p">,</span> <span class="n">weight_s</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">embedding_weights</span><span class="p">,</span> <span class="n">norm_weights</span></div>

<div class="viewcode-block" id="WeightGenerator.get_conv_weights"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightGenerator.get_conv_weights">[docs]</a>    <span class="k">def</span> <span class="nf">get_conv_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Adaptively generate weights for layer i in main branch convolutions.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (NxCxHxW tensor): Input features.</span>
<span class="sd">            i (int): Layer index.</span>
<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">              - conv_weights (list of tensors): Weights for the conv layers in</span>
<span class="sd">                the main branch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">mul_ref_label</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">AdaptiveAvgPool2d</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sh_fix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sw_fix</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">in_ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">out_ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">cks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_kernel_size</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">weight_reshaper</span> <span class="o">=</span> <span class="n">WeightReshaper</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_embed_input</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">fc_0</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fc_conv_0_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fc_1</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fc_conv_1_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fc_s</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;fc_conv_s_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">weight_0</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_weight</span><span class="p">(</span><span class="n">fc_0</span><span class="p">,</span> <span class="p">[</span><span class="n">in_ch</span><span class="p">,</span> <span class="n">out_ch</span><span class="p">,</span>
                                                         <span class="n">cks</span><span class="p">,</span> <span class="n">cks</span><span class="p">])</span>
        <span class="n">weight_1</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_weight</span><span class="p">(</span><span class="n">fc_1</span><span class="p">,</span> <span class="p">[</span><span class="n">in_ch</span><span class="p">,</span> <span class="n">in_ch</span><span class="p">,</span>
                                                         <span class="n">cks</span><span class="p">,</span> <span class="n">cks</span><span class="p">])</span>
        <span class="n">weight_s</span> <span class="o">=</span> <span class="n">weight_reshaper</span><span class="o">.</span><span class="n">reshape_weight</span><span class="p">(</span><span class="n">fc_s</span><span class="p">,</span> <span class="p">[</span><span class="n">in_ch</span><span class="p">,</span> <span class="n">out_ch</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">weight_0</span><span class="p">,</span> <span class="n">weight_1</span><span class="p">,</span> <span class="n">weight_s</span><span class="p">]</span></div>

<div class="viewcode-block" id="WeightGenerator.reset"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightGenerator.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Reset the network at the beginning of a sequence.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_weights</span> <span class="o">=</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="WeightReshaper"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightReshaper">[docs]</a><span class="k">class</span> <span class="nc">WeightReshaper</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Handles all weight reshape related tasks.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="WeightReshaper.reshape_weight"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightReshaper.reshape_weight">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_weight</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">weight_shape</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Reshape input x to the desired weight shape.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (tensor or list of tensors): Input features.</span>
<span class="sd">            weight_shape (list of int): Desired shape of the weight.</span>
<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">              - weight (tensor): Network weights</span>
<span class="sd">              - bias (tensor): Network bias.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If desired shape is a list, first divide x into the target list of</span>
        <span class="c1"># features.</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">weight_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_weights</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum_mul</span><span class="p">(</span><span class="n">weight_shape</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reshape_weight</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weight_shape</span><span class="p">)]</span>

        <span class="c1"># Get output shape, and divide x into either weight + bias or</span>
        <span class="c1"># just weight.</span>
        <span class="n">weight_shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">weight_shape</span>
        <span class="n">bias_size</span> <span class="o">=</span> <span class="n">weight_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">bias_size</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">weight_shape</span><span class="p">)</span>
            <span class="n">bias</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="o">-</span><span class="n">bias_size</span><span class="p">:]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">weight_shape</span><span class="p">)</span>
            <span class="n">bias</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">weight</span><span class="p">,</span> <span class="n">bias</span><span class="p">]</span></div>

<div class="viewcode-block" id="WeightReshaper.split_weights"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightReshaper.split_weights">[docs]</a>    <span class="k">def</span> <span class="nf">split_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">sizes</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;When the desired shape is a list, first divide the input to each</span>
<span class="sd">        corresponding weight shape in the list.</span>

<span class="sd">        Args:</span>
<span class="sd">            weight (tensor): Input weight.</span>
<span class="sd">            sizes (int or list of int): Target sizes.</span>
<span class="sd">        Returns:</span>
<span class="sd">            weight (list of tensors): Divided weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cur_size</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)):</span>
                <span class="c1"># For each target size in sizes, get the number of elements</span>
                <span class="c1"># needed.</span>
                <span class="n">next_size</span> <span class="o">=</span> <span class="n">cur_size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="c1"># Recursively divide the weights.</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split_weights</span><span class="p">(</span>
                    <span class="n">weight</span><span class="p">[:,</span> <span class="n">cur_size</span><span class="p">:</span><span class="n">next_size</span><span class="p">],</span> <span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">cur_size</span> <span class="o">=</span> <span class="n">next_size</span>
            <span class="k">assert</span> <span class="p">(</span><span class="n">next_size</span> <span class="o">==</span> <span class="n">weight</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">weights</span>
        <span class="k">return</span> <span class="n">weight</span></div>

<div class="viewcode-block" id="WeightReshaper.reshape_embed_input"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightReshaper.reshape_embed_input">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_embed_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Reshape input to be (B x C) X H X W.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (tensor or list of tensors): Input features.</span>
<span class="sd">        Returns:</span>
<span class="sd">            x (tensor or list of tensors): Reshaped features.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">reshape_embed_input</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="WeightReshaper.sum"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightReshaper.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sum all elements recursively in a nested list.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (nested list of int): Input list of elements.</span>
<span class="sd">        Returns:</span>
<span class="sd">            out (int): Sum of all elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span></div>

<div class="viewcode-block" id="WeightReshaper.sum_mul"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.WeightReshaper.sum_mul">[docs]</a>    <span class="k">def</span> <span class="nf">sum_mul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Given a weight shape, compute the number of elements needed for</span>
<span class="sd">        weight + bias. If input is a list of shapes, sum all the elements.</span>

<span class="sd">        Args:</span>
<span class="sd">            x (list of int): Input list of elements.</span>
<span class="sd">        Returns:</span>
<span class="sd">            out (int or list of int): Summed number of elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># x[0] accounts for bias.</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sum_mul</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span></div></div>


<div class="viewcode-block" id="AttentionModule"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.AttentionModule">[docs]</a><span class="k">class</span> <span class="nc">AttentionModule</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Attention module constructor.</span>

<span class="sd">    Args:</span>
<span class="sd">       atn_cfg (obj): Generator definition part of the yaml config file.</span>
<span class="sd">       data_cfg (obj): Data definition part of the yaml config file</span>
<span class="sd">       conv_2d_block: Conv2DBlock constructor.</span>
<span class="sd">       num_filters_each_layer (int): The number of filters in each layer.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atn_cfg</span><span class="p">,</span> <span class="n">data_cfg</span><span class="p">,</span> <span class="n">conv_2d_block</span><span class="p">,</span>
                 <span class="n">num_filters_each_layer</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_few_shot_K</span> <span class="o">=</span> <span class="n">data_cfg</span><span class="o">.</span><span class="n">initial_few_shot_K</span>
        <span class="n">num_input_channels</span> <span class="o">=</span> <span class="n">data_cfg</span><span class="o">.</span><span class="n">num_input_channels</span>
        <span class="n">num_filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">atn_cfg</span><span class="p">,</span> <span class="s1">&#39;num_filters&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">num_downsample_atn</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">atn_cfg</span><span class="p">,</span> <span class="s1">&#39;num_downsamples&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atn_query_first</span> <span class="o">=</span> <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">num_input_channels</span><span class="p">,</span> <span class="n">num_filters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atn_key_first</span> <span class="o">=</span> <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">num_input_channels</span><span class="p">,</span> <span class="n">num_filters</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples_atn</span><span class="p">):</span>
            <span class="n">f_in</span><span class="p">,</span> <span class="n">f_out</span> <span class="o">=</span> <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> \
                <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;atn_key_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                    <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">f_in</span><span class="p">,</span> <span class="n">f_out</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;atn_query_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                    <span class="n">conv_2d_block</span><span class="p">(</span><span class="n">f_in</span><span class="p">,</span> <span class="n">f_out</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

<div class="viewcode-block" id="AttentionModule.forward"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.AttentionModule.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_features</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">,</span> <span class="n">attention</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Get the attention map to combine multiple image features in the</span>
<span class="sd">        case of multiple reference images.</span>

<span class="sd">        Args:</span>
<span class="sd">            in_features ((NxK)xC1xH1xW1 tensor): Input feaures.</span>
<span class="sd">            label (NxC2xH2xW2 tensor): Target label.</span>
<span class="sd">            ref_label (NxC2xH2xW2 tensor): Reference label.</span>
<span class="sd">            attention (Nx(KxH1xW1)x(H1xW1) tensor): Attention maps.</span>
<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">              - out_features (NxC1xH1xW1 tensor): Attention-combined features.</span>
<span class="sd">              - attention (Nx(KxH1xW1)x(H1xW1) tensor): Attention maps.</span>
<span class="sd">              - atn_vis (1x1xH1xW1 tensor): Visualization for attention scores.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">in_features</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_few_shot_K</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">//</span> <span class="n">k</span>

        <span class="k">if</span> <span class="n">attention</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute the attention map by encoding ref_label and label as</span>
            <span class="c1"># key and query. The map represents how much energy for the k-th</span>
            <span class="c1"># map at location (h_i, w_j) can contribute to the final map at</span>
            <span class="c1"># location (h_i2, w_j2).</span>
            <span class="n">atn_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention_encode</span><span class="p">(</span><span class="n">ref_label</span><span class="p">,</span> <span class="s1">&#39;atn_key&#39;</span><span class="p">)</span>
            <span class="n">atn_query</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attention_encode</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="s1">&#39;atn_query&#39;</span><span class="p">)</span>

            <span class="n">atn_key</span> <span class="o">=</span> <span class="n">atn_key</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>  <span class="c1"># B X KHW X C</span>
            <span class="n">atn_query</span> <span class="o">=</span> <span class="n">atn_query</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># B X C X HW</span>
            <span class="n">energy</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">atn_key</span><span class="p">,</span> <span class="n">atn_query</span><span class="p">)</span>  <span class="c1"># B X KHW X HW</span>
            <span class="n">attention</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)(</span><span class="n">energy</span><span class="p">)</span>

        <span class="c1"># Combine the K features from different ref images into one by using</span>
        <span class="c1"># the attention map.</span>
        <span class="n">in_features</span> <span class="o">=</span> <span class="n">in_features</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># B X C X KHW</span>
        <span class="n">out_features</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">in_features</span><span class="p">,</span> <span class="n">attention</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>

        <span class="c1"># Get a slice of the attention map for visualization.</span>
        <span class="n">atn_vis</span> <span class="o">=</span> <span class="n">attention</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_features</span><span class="p">,</span> <span class="n">attention</span><span class="p">,</span> <span class="n">atn_vis</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="AttentionModule.attention_encode"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.AttentionModule.attention_encode">[docs]</a>    <span class="k">def</span> <span class="nf">attention_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">net_name</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Encode the input image to get the attention map.</span>

<span class="sd">        Args:</span>
<span class="sd">            img (NxCxHxW tensor): Input image.</span>
<span class="sd">            net_name (str): Name for attention network.</span>
<span class="sd">        Returns:</span>
<span class="sd">            x (NxC2xH2xW2 tensor): Encoded feature.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net_name</span> <span class="o">+</span> <span class="s1">&#39;_first&#39;</span><span class="p">)(</span><span class="n">img</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_downsample_atn</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net_name</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div></div>


<div class="viewcode-block" id="FlowGenerator"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.FlowGenerator">[docs]</a><span class="k">class</span> <span class="nc">FlowGenerator</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;flow generator constructor.</span>

<span class="sd">    Args:</span>
<span class="sd">       flow_cfg (obj): Flow definition part of the yaml config file.</span>
<span class="sd">       data_cfg (obj): Data definition part of the yaml config file.</span>
<span class="sd">       num_frames (int): Number of input frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow_cfg</span><span class="p">,</span> <span class="n">data_cfg</span><span class="p">,</span> <span class="n">num_frames</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">num_input_channels</span> <span class="o">=</span> <span class="n">data_cfg</span><span class="o">.</span><span class="n">num_input_channels</span>
        <span class="k">if</span> <span class="n">num_input_channels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">num_input_channels</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">num_prev_img_channels</span> <span class="o">=</span> <span class="n">get_paired_input_image_channel_number</span><span class="p">(</span><span class="n">data_cfg</span><span class="p">)</span>
        <span class="n">num_downsamples</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;num_downsamples&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;kernel_size&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">kernel_size</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">num_blocks</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;num_blocks&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">num_filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;num_filters&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
        <span class="n">max_num_filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;max_num_filters&#39;</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
        <span class="n">num_filters_each_layer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">max_num_filters</span><span class="p">,</span> <span class="n">num_filters</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">))</span>
                                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">flow_output_multiplier</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span>
                                              <span class="s1">&#39;flow_output_multiplier&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sep_up_mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;sep_up_mask&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">activation_norm_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;activation_norm_type&#39;</span><span class="p">,</span>
                                       <span class="s1">&#39;sync_batch&#39;</span><span class="p">)</span>
        <span class="n">weight_norm_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">flow_cfg</span><span class="p">,</span> <span class="s1">&#39;weight_norm_type&#39;</span><span class="p">,</span> <span class="s1">&#39;spectral&#39;</span><span class="p">)</span>

        <span class="n">base_conv_block</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">Conv2dBlock</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                                  <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                                  <span class="n">weight_norm_type</span><span class="o">=</span><span class="n">weight_norm_type</span><span class="p">,</span>
                                  <span class="n">activation_norm_type</span><span class="o">=</span><span class="n">activation_norm_type</span><span class="p">,</span>
                                  <span class="n">nonlinearity</span><span class="o">=</span><span class="s1">&#39;leakyrelu&#39;</span><span class="p">)</span>

        <span class="n">num_input_channels</span> <span class="o">=</span> <span class="n">num_input_channels</span> <span class="o">*</span> <span class="n">num_frames</span> <span class="o">+</span> \
            <span class="n">num_prev_img_channels</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_frames</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># First layer.</span>
        <span class="n">down_flow</span> <span class="o">=</span> <span class="p">[</span><span class="n">base_conv_block</span><span class="p">(</span><span class="n">num_input_channels</span><span class="p">,</span> <span class="n">num_filters</span><span class="p">)]</span>

        <span class="c1"># Downsamples.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span><span class="p">):</span>
            <span class="n">down_flow</span> <span class="o">+=</span> <span class="p">[</span><span class="n">base_conv_block</span><span class="p">(</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                          <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                          <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># Resnet blocks.</span>
        <span class="n">res_flow</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">num_downsamples</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocks</span><span class="p">):</span>
            <span class="n">res_flow</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">Res2dBlock</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                           <span class="n">weight_norm_type</span><span class="o">=</span><span class="n">weight_norm_type</span><span class="p">,</span>
                           <span class="n">activation_norm_type</span><span class="o">=</span><span class="n">activation_norm_type</span><span class="p">,</span>
                           <span class="n">order</span><span class="o">=</span><span class="s1">&#39;NACNAC&#39;</span><span class="p">)]</span>

        <span class="c1"># Upsamples.</span>
        <span class="n">up_flow</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span><span class="p">)):</span>
            <span class="n">up_flow</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nn</span><span class="o">.</span><span class="n">Upsample</span><span class="p">(</span><span class="n">scale_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
                        <span class="n">base_conv_block</span><span class="p">(</span><span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                                        <span class="n">num_filters_each_layer</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span>

        <span class="n">conv_flow</span> <span class="o">=</span> <span class="p">[</span><span class="n">Conv2dBlock</span><span class="p">(</span><span class="n">num_filters</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">)]</span>
        <span class="n">conv_mask</span> <span class="o">=</span> <span class="p">[</span><span class="n">Conv2dBlock</span><span class="p">(</span><span class="n">num_filters</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span>
                                 <span class="n">nonlinearity</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">down_flow</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">down_flow</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res_flow</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">res_flow</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">up_flow</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">up_flow</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_up_mask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">up_mask</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">up_flow</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_flow</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">conv_flow</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv_mask</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">conv_mask</span><span class="p">)</span>

<div class="viewcode-block" id="FlowGenerator.forward"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.FlowGenerator.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">,</span> <span class="n">ref_image</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Flow generator forward.</span>

<span class="sd">        Args:</span>
<span class="sd">            label (4D tensor) : Input label tensor.</span>
<span class="sd">            ref_label (4D tensor) : Reference label tensors.</span>
<span class="sd">            ref_image (4D tensor) : Reference image tensors.</span>
<span class="sd">        Returns:</span>
<span class="sd">            (tuple):</span>
<span class="sd">              - flow (4D tensor) : Generated flow map.</span>
<span class="sd">              - mask (4D tensor) : Generated occlusion mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label_concat</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">label</span><span class="p">,</span> <span class="n">ref_label</span><span class="p">,</span> <span class="n">ref_image</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">downsample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_flow</span><span class="p">(</span><span class="n">label_concat</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res_flow</span><span class="p">(</span><span class="n">downsample</span><span class="p">)</span>
        <span class="n">flow_feat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up_flow</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_flow</span><span class="p">(</span><span class="n">flow_feat</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flow_output_multiplier</span>

        <span class="n">mask_feat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up_mask</span><span class="p">(</span><span class="n">res</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sep_up_mask</span> <span class="k">else</span> <span class="n">flow_feat</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_mask</span><span class="p">(</span><span class="n">mask_feat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">flow</span><span class="p">,</span> <span class="n">mask</span></div></div>


<div class="viewcode-block" id="LabelEmbedder"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.LabelEmbedder">[docs]</a><span class="k">class</span> <span class="nc">LabelEmbedder</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Embed the input label map to get embedded features.</span>

<span class="sd">    Args:</span>
<span class="sd">        emb_cfg (obj): Embed network configuration.</span>
<span class="sd">        num_input_channels (int): Number of input channels.</span>
<span class="sd">        num_hyper_layers (int): Number of hyper layers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">emb_cfg</span><span class="p">,</span> <span class="n">num_input_channels</span><span class="p">,</span> <span class="n">num_hyper_layers</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">num_filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">emb_cfg</span><span class="p">,</span> <span class="s1">&#39;num_filters&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
        <span class="n">max_num_filters</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">emb_cfg</span><span class="p">,</span> <span class="s1">&#39;max_num_filters&#39;</span><span class="p">,</span> <span class="mi">1024</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">emb_cfg</span><span class="p">,</span> <span class="s1">&#39;arch&#39;</span><span class="p">,</span> <span class="s1">&#39;encoderdecoder&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span> <span class="o">=</span> <span class="n">num_downsamples</span> <span class="o">=</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="n">emb_cfg</span><span class="p">,</span> <span class="s1">&#39;num_downsamples&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">kernel_size</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">emb_cfg</span><span class="p">,</span> <span class="s1">&#39;kernel_size&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">weight_norm_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">emb_cfg</span><span class="p">,</span> <span class="s1">&#39;weight_norm_type&#39;</span><span class="p">,</span> <span class="s1">&#39;spectral&#39;</span><span class="p">)</span>
        <span class="n">activation_norm_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">emb_cfg</span><span class="p">,</span> <span class="s1">&#39;activation_norm_type&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">unet</span> <span class="o">=</span> <span class="s1">&#39;unet&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_decoder</span> <span class="o">=</span> <span class="s1">&#39;decoder&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">arch</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">unet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span> <span class="o">=</span> <span class="n">num_hyper_layers</span> \
            <span class="k">if</span> <span class="n">num_hyper_layers</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">num_downsamples</span>

        <span class="n">base_conv_block</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">HyperConv2dBlock</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                                  <span class="n">padding</span><span class="o">=</span><span class="p">(</span><span class="n">kernel_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span>
                                  <span class="n">weight_norm_type</span><span class="o">=</span><span class="n">weight_norm_type</span><span class="p">,</span>
                                  <span class="n">activation_norm_type</span><span class="o">=</span><span class="n">activation_norm_type</span><span class="p">,</span>
                                  <span class="n">nonlinearity</span><span class="o">=</span><span class="s1">&#39;leakyrelu&#39;</span><span class="p">)</span>

        <span class="n">ch</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">max_num_filters</span><span class="p">,</span> <span class="n">num_filters</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">))</span>
              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conv_first</span> <span class="o">=</span> <span class="n">base_conv_block</span><span class="p">(</span><span class="n">num_input_channels</span><span class="p">,</span> <span class="n">num_filters</span><span class="p">,</span>
                                          <span class="n">activation_norm_type</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="c1"># Downsample.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span><span class="p">):</span>
            <span class="n">is_hyper_conv</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_hyper_layers</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_decoder</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;down_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                    <span class="n">base_conv_block</span><span class="p">(</span><span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ch</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                                    <span class="n">is_hyper_conv</span><span class="o">=</span><span class="n">is_hyper_conv</span><span class="p">))</span>

        <span class="c1"># Upsample.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_decoder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">upsample</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Upsample</span><span class="p">(</span><span class="n">scale_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_downsamples</span><span class="p">)):</span>
                <span class="n">ch_i</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="mi">2</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unet</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">num_downsamples</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;up_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span>
                        <span class="n">base_conv_block</span><span class="p">(</span><span class="n">ch_i</span><span class="p">,</span> <span class="n">ch</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                        <span class="n">is_hyper_conv</span><span class="o">=</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_hyper_layers</span><span class="p">)))</span>

<div class="viewcode-block" id="LabelEmbedder.forward"><a class="viewcode-back" href="../../../imaginaire.generators.html#imaginaire.generators.fs_vid2vid.LabelEmbedder.forward">[docs]</a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Embedding network forward.</span>

<span class="sd">        Args:</span>
<span class="sd">            input (NxCxHxW tensor): Network input.</span>
<span class="sd">            weights (list of tensors): Conv weights if using hyper network.</span>
<span class="sd">        Returns:</span>
<span class="sd">            output (list of tensors): Network outputs at different layers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">conv_first</span><span class="p">(</span><span class="nb">input</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span><span class="p">):</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;down_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="c1"># For hyper networks, the hyper layers are at the last few layers</span>
            <span class="c1"># of decoder (if the network has a decoder). Otherwise, the hyper</span>
            <span class="c1"># layers will be at the first few layers of the network.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_decoder</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">conv_weights</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># We will use outputs from different layers as input to different</span>
            <span class="c1"># SPADE layers in the main branch.</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conv</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_decoder</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>

        <span class="c1"># If the network has a decoder, will use outputs from the decoder</span>
        <span class="c1"># layers instead of the encoding layers.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">unet</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span><span class="p">)):</span>
            <span class="n">input_i</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unet</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">input_i</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">input_i</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">input_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upsample</span><span class="p">(</span><span class="n">input_i</span><span class="p">)</span>
            <span class="n">layer</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;up_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="c1"># The last few layers will be hyper layers if necessary.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_hyper_layers</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">input_i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conv</span> <span class="o">=</span> <span class="n">layer</span><span class="p">(</span><span class="n">input_i</span><span class="p">,</span> <span class="n">conv_weights</span><span class="o">=</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conv</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unet</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_downsamples</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">output</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright NVIDIA

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>